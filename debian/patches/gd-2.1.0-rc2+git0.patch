diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 6228cba..daeaa26 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -22,14 +22,17 @@ SET (LIBGD_SRC_FILES
 	gd_io_stream.cxx
 	gd_io_stream.h
 	gd_io_dp.c
+	gd_interpolation.c
 	gd_gif_in.c
 	gd_gif_out.c
 	gd_io_file.c
 	gd_io_ss.c
 	gd_jpeg.c
+	gd_matrix.c
 	gd_nnquant.c
 	gd_nnquant.h
 	gd_png.c
+	gd_rotate.c
 	gd_tiff.c
 	gd_tga.c
 	gd_tga.h
diff --git a/src/gd.c b/src/gd.c
index a5b3556..c404495 100644
--- a/src/gd.c
+++ b/src/gd.c
@@ -2275,11 +2275,11 @@ BGD_DECLARE(gdImagePtr) gdImageClone (gdImagePtr src) {
 	if (src->trueColor == 0) {
 		dst->colorsTotal = src->colorsTotal;
 		for (i = 0; i < gdMaxColors; i++) {
-			dst->red[gdMaxColors]   = src->red[gdMaxColors];
-			dst->green[gdMaxColors] = src->green[gdMaxColors];
-			dst->blue[gdMaxColors]  = src->blue[gdMaxColors];
-			dst->alpha[gdMaxColors] = src->alpha[gdMaxColors];
-			dst->open[gdMaxColors]  = src->open[gdMaxColors];
+			dst->red[i]   = src->red[i];
+			dst->green[i] = src->green[i];
+			dst->blue[i]  = src->blue[i];
+			dst->alpha[i] = src->alpha[i];
+			dst->open[i]  = src->open[i];
 		}
 		for (i = 0; i < src->sy; i++) {
 			for (x = 0; x < src->sx; x++) {
@@ -3335,9 +3335,9 @@ static void gdImageSetAAPixelColor(gdImagePtr im, int x, int y, int color, int t
 static void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int col)
 {
 	/* keep them as 32bits */
-	long x, y, inc;
-	long dx, dy,tmp;
-	int w, wid, wstart; 
+	uint32_t x, y;
+	int32_t dx, dy, inc;
+	int tmp, w, wid, wstart; 
 	int thick = im->thick; 
 
 	if (!im->trueColor) {
@@ -3392,17 +3392,17 @@ static void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int co
 			dx = x2 - x1;
 			dy = y2 - y1;
 		}
-		x = x1 << 16;
-		y = y1 << 16;
+		x = (uint32_t)x1;
+		y = (uint32_t)y1 << 16;
 		inc = (dy * 65536) / dx;
 		/* TBB: set the last pixel for consistency (<=) */
-		while ((x >> 16) <= x2) {
+		while (x <= x2) {
 			wstart = (y >> 16) - wid / 2;
 			for (w = wstart; w < wstart + wid; w++) {
-			    gdImageSetAAPixelColor(im, (x >> 16) , w , col , (y >> 8) & 0xFF);
-			    gdImageSetAAPixelColor(im, (x >> 16) , w + 1 , col, (~y >> 8) & 0xFF);
+			    gdImageSetAAPixelColor(im, x , w , col , (y >> 8) & 0xFF);
+			    gdImageSetAAPixelColor(im, x , w + 1 , col, (~y >> 8) & 0xFF);
 			}
-			x += (1 << 16);
+			x++;
 			y += inc;
 		}
 	} else {
@@ -3416,18 +3416,18 @@ static void gdImageAALine (gdImagePtr im, int x1, int y1, int x2, int y2, int co
 			dx = x2 - x1;
 			dy = y2 - y1;
 		}
-		x = x1 << 16;
-		y = y1 << 16;
+		x = (uint32_t)x1 << 16;
+		y = (uint32_t)y1;
 		inc = (dx * 65536) / dy;
 		/* TBB: set the last pixel for consistency (<=) */
-		while ((y >> 16) <= y2) {
+		while (y <= y2) {
 			wstart = (x >> 16) - wid / 2;
 			for (w = wstart; w < wstart + wid; w++) {
-			    gdImageSetAAPixelColor(im, w , y >> 16  , col, (x >> 8) & 0xFF);
-			    gdImageSetAAPixelColor(im, w + 1, y >> 16, col, (~x >> 8) & 0xFF);
+			    gdImageSetAAPixelColor(im, w , y  , col, (x >> 8) & 0xFF);
+			    gdImageSetAAPixelColor(im, w + 1, y, col, (~x >> 8) & 0xFF);
 			}
 			x += inc;
-			y += (1 << 16);
+			y++;
 		}
 	}
 }
diff --git a/src/gd_interpolation.c b/src/gd_interpolation.c
index b0a16ad..88dca85 100644
--- a/src/gd_interpolation.c
+++ b/src/gd_interpolation.c
@@ -619,6 +619,10 @@ static double filter_welsh(const double x)
 }
 #endif
 
+#if defined(_MSC_VER) && !defined(inline)
+# define inline __inline
+#endif 
+
 /* Copied from upstream's libgd */
 static inline int _color_blend (const int dst, const int src)
 {
@@ -2191,17 +2195,18 @@ gdImagePtr gdImageRotateBicubicFixed(gdImagePtr src, const float degrees, const
 
 BGD_DECLARE(gdImagePtr) gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)
 {
-	const int angle_rounded = (int)floor(angle);
-	
+	/* round to two decimals and keep the 100x multiplication to use it in the common square angles 
+	   case later. Keep the two decimal precisions so smaller rotation steps can be done, useful for
+	   slow animations, f.e. */
+	const int angle_rounded = fmod((int) floorf(angle * 100), 360 * 100);
+
 	if (bgcolor < 0) {
 		return NULL;
 	}
 
-	/* no interpolation needed here */
+	/* 0 && 90 degrees multiple rotation, 0 rotation simply clones the return image and convert it
+	   to truecolor, as we must return truecolor image. */
 	switch (angle_rounded) {
-
-		case  360:
-		case -360:
 		case    0: {
 			gdImagePtr dst = gdImageClone(src);
 
@@ -2214,16 +2219,16 @@ BGD_DECLARE(gdImagePtr) gdImageRotateInterpolated(const gdImagePtr src, const fl
 			return dst;
 		}
 
-		case -270:
-		case   90:
+		case -2700:
+		case   9000:
 			return gdImageRotate90(src, 0);
 
-		case -180:
-		case  180:
+		case -18000:
+		case  18000:
 			return gdImageRotate180(src, 0);
 
-		case  -90:
-		case  270:
+		case  -9000:
+		case  27000:
 			return gdImageRotate270(src, 0);
 	}
 
diff --git a/src/gdhelpers.c b/src/gdhelpers.c
index 6ca96ea..d11771b 100644
--- a/src/gdhelpers.c
+++ b/src/gdhelpers.c
@@ -61,25 +61,24 @@ gd_strtok_r (char *s, char *sep, char **state)
 	return result;
 }
 
-inline void *
-gdCalloc (size_t nmemb, size_t size)
+const  void * gdCalloc (size_t nmemb, size_t size)
 {
 	return calloc (nmemb, size);
 }
 
-inline void *
+const  void *
 gdMalloc (size_t size)
 {
 	return malloc (size);
 }
 
-inline void *
+const  void *
 gdRealloc (void *ptr, size_t size)
 {
 	return realloc (ptr, size);
 }
 
-inline void *
+const  void *
 gdReallocEx (void *ptr, size_t size)
 {
 	void *newPtr = gdRealloc (ptr, size);
diff --git a/src/gdhelpers.h b/src/gdhelpers.h
index 0a5df08..a5d6bda 100644
--- a/src/gdhelpers.h
+++ b/src/gdhelpers.h
@@ -20,12 +20,12 @@ extern "C" {
 		in gd.h, where callers can utilize it to correctly
 		free memory allocated by these functions with the
 		right version of free(). */
-	void *gdCalloc (size_t nmemb, size_t size);
-	void *gdMalloc (size_t size);
-	void *gdRealloc (void *ptr, size_t size);
+	const void *gdCalloc (size_t nmemb, size_t size);
+	const void *gdMalloc (size_t size);
+	const void *gdRealloc (void *ptr, size_t size);
 	/* The extended version of gdReallocEx will free *ptr if the
 	 * realloc fails */
-	void *gdReallocEx (void *ptr, size_t size);
+	const void *gdReallocEx (void *ptr, size_t size);
 
 	/* Returns nonzero if multiplying the two quantities will
 		result in integer overflow. Also returns nonzero if
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 3f22f39..5f8706f 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -41,6 +41,7 @@ if (BUILD_TEST)
 		gdimagepixelate
 		gdimagepolygon
 		gdimagerectangle
+		gdimagerotate
 		gdimagescatterex
 		gdimagesetpixel
 		gdnewfilectx
diff --git a/tests/gdimagerotate/CMakeLists.txt b/tests/gdimagerotate/CMakeLists.txt
new file mode 100644
index 0000000..6aa98d2
--- /dev/null
+++ b/tests/gdimagerotate/CMakeLists.txt
@@ -0,0 +1,11 @@
+SET(TESTS_FILES
+	bug00067
+	php_bug_64898
+)
+
+FOREACH(test_name ${TESTS_FILES})
+	add_executable(${test_name} "${test_name}.c")
+	target_link_libraries (${test_name} gdTest)
+	get_target_property(test_path ${test_name} LOCATION)
+	ADD_TEST(${test_name} ${test_path})
+ENDFOREACH(test_name)
diff --git a/tests/gdimagerotate/bug00067.c b/tests/gdimagerotate/bug00067.c
index 24328a8..4a65959 100644
--- a/tests/gdimagerotate/bug00067.c
+++ b/tests/gdimagerotate/bug00067.c
@@ -12,6 +12,8 @@ int main()
 	const char *file_exp = "gdimagerotate/bug00067";
 	FILE *fp;
 	int color;
+	int error = 0;
+	int angle;
 
 	sprintf(path, "%s/%s", GDTEST_TOP_DIR, file_im);
 
@@ -39,9 +41,7 @@ int main()
 		return 1;
 	}
 
-	int error = 0;
-
-	for (int angle = 0; angle <= 180; angle += 15) {
+	for (angle = 0; angle <= 180; angle += 15) {
 
 		exp = gdImageRotateInterpolated(im, angle, color);
 
